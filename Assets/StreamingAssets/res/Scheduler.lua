---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by hsk.
--- DateTime: 2018/10/23 10:38 PM
---

---@class ScheduleManager
local scheduler = {}

---@type ScheduleEntry[]
local schedulEntries = {}

local logger = require("Logger")

--创建新的任务
---@param delay number 任务执行延迟时间-s
---@param callback fun(bool state,table object) 任务结束时的回调函数
---@return ScheduleEntry
local function CreateSchedulEntry(delay, callback)
    assert(callback ~= nil, "callback cannot be nil")

    if delay <= 0 then
        delay = 0
    end

    local running = false                       --是否正在执行该任务
    local during = 0                            --开始执行时间
    local lastCallTime = 0                      --上次循环执行时间

    ---@class ScheduleEntry
    ---@field delay number 延迟时间
    ---@field callback fun(...):void 回调函数
    ---@field canceled boolean 任务是否已经取消
    ---@field loop boolean 是否循环执行
    ---@field interval number 循环间隔时间
    ---@field oncanceled fun(...):void 取消任务时的回调函数
    ---@field ignoreTimeScale boolean 是否忽略时间缩放
    local newentry = { delay = delay,
                       callback = callback,
                       canceled = false,
                       loop = false,
                       interval = 1,
                       oncalceled = nil,
                       ignoreTimeScale = false }

    ---任务知否正在执行
    ---@return boolean
    function newentry:isrunning()
        return running
    end

    ---任务是否已经取消
    ---@return boolean
    function newentry:iscanceled()
        return self.canceled
    end

    ---执行任务
    ---@param self ScheduleEntry
    local function run(self)
        running = true
        if self.callback ~= nil then
            local success,error = pcall(self.callback)
            if not success then
                logger:Error(error)
            end
        end
    end

    ---尝试执行任务
    ---@param deltaTime number
    ---@return boolean 任务是否执行结束
    function newentry:tryrun(deltaTime)
        if self:isrunning() and not self.loop then
            return true
        end

        during = during + deltaTime

        if self.loop then
            if not self:isrunning() then
                if during >= delay then
                    run(self)
                    lastCallTime = during
                end
            elseif during - lastCallTime >= (self.interval < 0 and -self.interval or self.interval) then
                run(self)
                lastCallTime = during
            end
        elseif during >= delay then
            run(self)
            return true
        end

        return false
    end

    ---取消任务
    function newentry:cancel()
        self.canceled = true
        if self.oncalceled ~= nil then
            self.oncalceled()
        end
    end

    return newentry
end

---检查任务列表，看是否有到时间需要执行的任务
---@deltaTime number，本次检查时间步长
local function TickSchedules(deltaTime)
    if schedulEntries == nil then
        return
    end
    local i = 1
    while i <= #schedulEntries do
        local entry = schedulEntries[i]
        if entry ~= nil and (entry:iscanceled() or entry:tryrun(deltaTime)) then
            table.remove(schedulEntries, i)
        else
            i = i + 1
        end
    end
end

---延时执行任务
---@param delay number 延时时长，秒为单位
---@param callback fun(...):void 任务函数
---@return ScheduleEntry
function scheduler.Schedule(delay, callback)
    local newentry = CreateSchedulEntry(delay, callback)
    if newentry ~= nil then
        table.insert(schedulEntries, newentry)
        print("Create a new schedule,schedule count:", #schedulEntries)
    end
    TickSchedules(0)
    return newentry
end

---循环执行延迟任务，需要注意的是，任务会一直执行，除非用户调用取消才会停止
---@param delay number 任务开始时间
---@param interval number 循环间隔时间
---@param callback fun(...):void 循环执行函数
---@param oncancel fun(...):void 调用取消时的回调函数
---@return ScheduleEntry
function scheduler.LoopSchedule(delay, interval, callback, oncancel)
    local newentry = CreateSchedulEntry(delay, callback)
    if newentry ~= nil then
        newentry.loop = true
        newentry.oncalceled = oncancel
        newentry.interval = interval
        table.insert(schedulEntries, newentry)

        TickSchedules(0)
    end
    return newentry
end

---取消延迟执行的任务
---@param entry ScheduleEntry
function scheduler.CancelSchedule(entry)
    assert(entry ~= nil,"CancelSchedule:entry cannot be nil")
    entry:cancel()
end

---对应 Unity Update 函数
---@param deltaTime number : 上一帧执行时间，对应 Time.deltaTime
local function UnityUpdate(deltaTime)
    TickSchedules(deltaTime)
end

--与 unity 事件进行绑定
local ticker = require("UnityTicker")
ticker:StartListenUpdate(UnityUpdate)

return scheduler