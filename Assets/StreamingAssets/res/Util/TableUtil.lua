---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by hsk.
--- DateTime: 2018/10/25 11:10 PM
---

local TableUtil = {}

---从列表 t 中删除从 pos 开始的 num 个元素。
---@generic T
---@param t T[] 删除元素的列表
---@param pos number 开始删除索引
---@param num number 要删除元素的数量，如果没有指定，则删除 pos 之后的所有元素
function TableUtil.ClearArray(t,pos,num)
    assert(t ~= nil,"The array:t is nil")
    assert(pos > 0 and pos<=#t,"The pos is out range")

    --如果没有指定 num 值，则默认 pos 之后全部删除
    num = num or #t

    --需要删除的最后一个元素的索引
    local index = 0
    if num >= 0 then
        index = pos + num - 1
    else
        --为了保持从尾往头删，调换头尾索引
        pos,index = pos + num + 1,pos
    end

    --对头尾索引进行限制，避免超界
    index = index > #t and #t or index
    index = index < 1 and 1 or index
    pos = pos < 1 and 1 or pos

    local maxn = #t - index + pos - 1

    table.move(t,index+1,#t,pos)

    local temp = #t
    while temp > maxn  do
        table.remove(t,temp)
        temp = temp - 1
    end
end

---从列表 t 中删除，所有满足 match 条件的元素
---@generic T
---@param t T[] 列表
---@param match fun(v:T):boolean 筛选列表
function TableUtil.RemoveAll(t,match)
    assert(match ~= nil,"Then match argument cannot be nil")

    --找到第一个需要删除的元素的索引 num
    local num = 1
    while(num < #t and not match(t[num])) do
        num = num + 1
    end

    --如果需要删除的索引超过列表最大索引，则表明没有满足删除条件的元素
    if num > #t then
        return 0
    end

    --将 num 之后不需要删除的元素，移动到需要删除的元素之前，这样可以避免拷贝
    local i = num + 1
    while(i <= #t) do

        while(i <= #t and match(t[i])) do
            i = i + 1
        end

        if i <= #t then
            t[num] = t[i]
            num = num + 1
            i = i + 1
        end
    end
    local result = #t - num + 1

    --清楚需要删除的元素
    TableUtil.ClearArray(t,num,result)
    return result
end

---根据指定方法match，对列表进行排序
---@generic T
---@param t T[]
---@param match fun(a:T,b:T):number
function TableUtil.Sort(t,match)

    ---分区函数：将 t 中所有元素进行分区，大于 pivot 的排在左侧，大于 pivot 的排在右侧
    local function partition(p,r)
        --随机取 pivot，减少最坏情况出现几率
        local random = math.random(p,r)
        t[random],t[r] = t[r],t[random]
        local pivot = t[r]

        --用 i 来记录大于 pivot 的最左侧的值
        local i = p

        --所有元素,把所有小于 pivot 的元素，移动到 i 的左边
        for j=p,r-1 do
            if match(t[j],pivot) < 0 then
                t[i],t[j] = t[j],t[i]
                i = i+1
            end
        end

        --所有小于 pivot 的元素都被交换到了 i 的左边，这里只需要交换 pivot 和 t[i] 即可完成分区
        t[i],t[r] = t[r],t[i]
        return i
    end


    local function quick_sort(p,r)

        if p >= r then
            return
        end

        local pivotIndex = partition(p,r)
        quick_sort(p,pivotIndex-1)
        quick_sort(pivotIndex+1,r)
    end

    quick_sort(1,#t)
end

return TableUtil